| Feature        | Virtual Machine         | Docker Container    |
| -------------- | ----------------------- | ------------------- |
| OS             | Full guest OS           | Shares host OS      |
| Size           | GBs                     | MBs                 |
| Startup time   | Minutes                 | Seconds             |
| Performance    | Slower (more overhead)  | Near-native         |
| Isolation      | Strong (hardware-level) | Process-level       |
| Resource usage | Heavy                   | Lightweight         |
| Portability    | Medium                  | Very high           |
| Best for       | Different OS needs      | Microservices, apps |


docker build -t myapp:1.0 .
-t assigns a name and optional version (tag) to the Docker image youâ€™re building.
docker build â†’ build image

-t myapp:1.0 â†’ image name + tag

. â†’ current directory (build context)

docker run -d -p 8080:8080 --name mycontainer myapp:1.0

docker stop mycontainer
docker rm mycontainer

docker rmi myapp:1.0 //for image


Push to docker hub
-----------------
1ï¸âƒ£Create a Docker Hub account
username = loki123

2ï¸âƒ£ Login to Docker Hub from terminal
docker login

3ï¸âƒ£ Build your Docker image (if not built already)
docker build -t myapp .

<dockerhub-username>/<image-name>:<tag>
Ex:- docker tag myapp loki123/myapp:1.0
docker push loki123/myapp:1.0



volumes
-------
Docker volumes = the safe place for data that should outlive containers ğŸ“¦ğŸ³

If containers are cattle (disposable), volumes are the barn where the data stays.



Docker Client  â†’  Docker Daemon  â†’  Docker Registry

docker ps //shows running containers
docker ps -a //running + stopped

docker pull nginx
docker images //lists all Docker images stored locally on your machine (images youâ€™ve pulled or built).

docker run -p 8080:80 nginx //port mapping
8080 â†’ your local machine
80 â†’ port inside the container where Nginx listens


Name the container
docker run -d -p 8080:80 --name my-nginx nginx

docker stop my-nginx
docker restart mynginx

With -d
------Your terminal is free
If you close the terminal â†’ container keeps running

d means: â€œRun it, but donâ€™t show me â€” let it run by itself.â€

| Flag    | What happens                    |
| ------- | ------------------------------- |
| `-d`    | Run container in **background** |
| no `-d` | Run container in **foreground** |


Use -d when:

Running servers (Nginx, databases, APIs)

You donâ€™t need live logs in the terminal

You want the container to run continuously

Interactive Mode (-it)
---------------------
docker run -it ubuntu //creates new container and opens the terminal
Docker starts an Ubuntu container

You are inside the container

You see a prompt like:  root@a1b2c3d4:/#

We can use 
ls
pwd
apt update


docker logs <container_id_or_name> //shows message from the container
docker logs -f my-nginx //live logs



docker exec -it mynginx sh //already container exists
docker rm mynginx
docker rm -f mongo //force remove even if it is running
docker container prune //remove stopped containers


What is docker commit?

docker commit creates a new Docker image from the current state of a running (or stopped) container.

ğŸ‘‰ Itâ€™s like taking a snapshot of a container and saving it as an image.
docker commit <container_id_or_name> <new_image_name:tag>
1ï¸âƒ£ Run a container
docker run -it ubuntu bash

2ï¸âƒ£ Make changes inside container
apt update
apt install -y curl

3ï¸âƒ£ Exit container
exit

4ï¸âƒ£ Commit container to image
docker commit <container_id> myubuntu:curl


Now you have:

myubuntu:curl





docker exec -it mycontainer /bin/bash
1ï¸âƒ£ docker exec
Executes a command inside a running container
Container must already be running

/bin/bash
Starts a Bash shell inside the container
Bash is a command-line shell that lets you talk to the operating system using commands.

Docker Volumes
------------
What happens if a container is deleted?All data inside container is gone

What is a Volume?

Managed by Docker

Lives outside container filesystem

Survives container deletion

| Type       | Managed By | Use Case         |
| ---------- | ---------- | ---------------- |
| Volume     | Docker     | Databases (best) |
| Bind Mount | Host OS    | Dev / local      |
| tmpfs      | Memory     | Sensitive data   |
| Volume                | Bind Mount                 |
| --------------------- | -------------------------- |
| Managed by Docker     | Managed by you             |
| Stored in Docker area | Stored anywhere you choose |
| Safer & portable      | Tied to host path          |
| Best for data         | Best for code              |
| Used in production    | Used in development        |
Bind mounts can accidentally overwrite container files

Volumes are isolated and safer

docker volume create mydata
docker volume ls

docker run -d \
  --name mongo1 \
  -v mydata:/data/db \
  mongo

docker rm -f mongo1




Docker compose
------------
Run everything with::
docker compose up
docker compose up -d

docker compose stop
Stop & remove:
docker compose down


docker-compose.yml :-(Backend + Mongo):

version: "3.9"

services:
  backend:
    image: node:18
    ports:
      - "3000:3000"
    depends_on:
      - mongo

  mongo:
    image: mongo
    volumes:
      - mongo_data:/data/db

volumes:
  mongo_data:



A Dockerfile is a step-by-step recipe to create a Docker image.
FROM node:18
WORKDIR /app
COPY . .
RUN npm install
CMD ["npm", "start"]

1ï¸âƒ£ FROM node:18
What it does

Sets the base image

Pulls Node.js v18 with OS + Node + npm preinstalled

Why we need it

Containers donâ€™t have Node by default

Saves you from installing Node manually


2ï¸âƒ£ WORKDIR /app
What it does

Sets /app as the current working directory

If /app doesnâ€™t exist â†’ Docker creates it

Why itâ€™s useful

All following commands run inside /app

Cleaner than writing /app everywhere

3ï¸âƒ£ COPY . .
What it does

Copies all files from host project directory

Into the containerâ€™s /app directory

4ï¸âƒ£ RUN npm install
What it does

Installs dependencies listed in package.json

Creates node_modules inside image
At runtime, Docker executes: 8pm start

5ï¸âƒ£ CMD ["npm", "start"]
What it does
Defines default command

Runs when container starts

Build and start afterwards




Why should you COPY package.json first?

Short answer: Docker layer caching = faster builds ğŸš€
package.json changes rarely

Your source code changes often

So:

If only your code changes â†’ Docker reuses the cached npm install layer

If dependencies change â†’ Docker correctly reruns npm install







EXPOSE 3000.    Says: â€œthis container listens on port 3000â€.  Does not make anything reachable

docker run -p 3000:3000 myimage
Maps host â†’ container ports

Makes the app reachable from your machine

You choose the ports



docker run -P myimage
Publishes all EXPOSEd ports(connected with expose). Publish everything randomly
















